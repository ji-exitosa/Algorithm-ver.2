	┌───────┬───────────┬───────────────────────────┐
	│백준		│17090번		│미로찾기						│
	└───────┴───────────┴───────────────────────────┘
	┌───────────────┐
	│전반적인 아이디어	│
	└───────────────┘
	최대 500X500 미로가 있고 적혀있는 문자에 따라 다른칸으로 이동 가능
	4종류, x축으로 +1, -1 / y축으로 +1, -1 이동 가능
	미로 탈출은 보통은 가장자리에 있을 때 빨리 탈출할 가능성이 높다고 생각해서
	가장자리부터 풀면 좋겠다고 생각함.
	따라서 BFS보다는 DFS로 퍼지는게 좋을 것 같고, 뮤탈리스크할때 배운 dp 적용하면 좋을 것 같음
	음 dp가 맞는지 모르겠는데 아마 같은 개념인듯?
	아 DFS나 BFS로 돌리면 끊기는 지점있을 때 더 진행을 못하니까 그냥 이중FOR문느낌으로 가는게 낫겠다.
	음,,, 시작점이 크게 중요하지 않을거같긴한데 ,, 
	가장자리중 한 자리를 짚어서 그 지점부터 URDL대로 움직이다가 밖으로 나가는데 성공하면 그 루트에 전부 밖에 나갈 수 있는 칸이라고 표시를 해두면
	다음번에 그 지점에 도달했을 때 다시 계산해볼 필요가 없을 것이라고 생각.
	성공했을때 쭉 뽑아서 그부분 성공했다고 표시하는 방법은 루트 움직이면서 이미 지나간 길을 방문체크하고 STACK이나 QUEUE에 넣으면 될듯
	아 탈출 가능한 수 구하는거니까.. stack이나 queue에 쌓아둔다음에 성공하면 그 스택크기만큼 answer에 더해주면 좋을듯
	
	
	U,R,D,L이 있으니까 이걸 상수로 지정하고 
	int [][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};
	이렇게 해두고 dir[U][0], dir[U][1] 이런식으로 쓰면 덜헷갈릴 것 같음
	
	
	┌───────┐
	│예제 1	│
	└───────┘
	아이디어가 맞는지 검증, 예외 찾아내기
	
	┌───────┐
	│예제 2	│
	└───────┘
	아이디어가 맞는지 검증, 예외 찾아내기
	
	┌───────┐
	│예제 3	│
	└───────┘
	아이디어가 맞는지 검증, 예외 찾아내기

	.
	.
	.

	┌───────────────┐
	│구상끝에 내린 결론	│
	└───────────────┘